// Generated by `npm run compile`
(function () {
  return function () {
    const CHASE = 0;
    const FLASH = 1;
    const GLOW = 2;
    const JOIN_HALVES = 3;
    const LEDS = 4;
    const NOISE = 5;
    const OFF = 6;
    const PULSE = 7;
    const RAINBOW = 8;
    const SPARKLE = 9;
    const NUM_DISPLAY_MODES = 10;
    const MAX_PARTICLES = 32;
    const POS_SCALE = 10;
    const POS_MAX = ROPE_LEDS * POS_SCALE;
    const COLOR_SET = 0;
    const COLOR_ADD = 1;
    const COLOR_BLEND = 2;
    const COLLIDE_OFF = 0;
    const COLLIDE_BOOM = 1;
    const HSV = 1;
    const RGB = 2;

    const particles = Array.from(Array(MAX_PARTICLES), () => ({
      age: 0,
      pos: 0,
      hue: 0,
      len: 0,
      speed: 0,
      hue_v: 0,
      bright: 0,
      respawn: 0,
      wrap: false,
    }));
    let current_mode;
    let last_auto = 0;
    let r_mult = 255;
    let g_mult = 255;
    let b_mult = 255;
    let color_mode = HSV;
    let collision_mode = COLLIDE_OFF;
    let collide_same_direction = false;
    let state_loop = 0;
    let state;
    let fade_speed = 16;
    let rope_offset = 0;
    const FLASH_STEP = 10;
    function blend(amount, a, b) {
      let af = a / 255.0;
      let bf = b / 255.0;
      return uint8(255 * sqrt((1 - amount) * af * af + amount * bf * bf));
    }
    function rgb(pixel, r, g, b, mode = COLOR_SET) {
      let position = (rope_offset + pixel) * 3;
      if (mode == COLOR_SET) {
        ledBuffer[position + 1] = r;
        ledBuffer[position + 0] = g;
        ledBuffer[position + 2] = b;
        return;
      }
      let oR = ledBuffer[position + 1];
      let oG = ledBuffer[position + 0];
      let oB = ledBuffer[position + 2];
      if (mode == COLOR_ADD) {
        let maxPrev = max(oR, max(oG, oB));
        let maxNow = max(r, max(g, b));
        if (maxNow + maxPrev > 255) {
          let scale = (255.0 - maxNow) / 255;
          oR = uint8(oR * scale);
          oG = uint8(oG * scale);
          oB = uint8(oB * scale);
        }
        r = uint8(r + oR);
        g = uint8(g + oG);
        b = uint8(b + oB);
      } else if (mode == COLOR_BLEND) {
        r = blend(0.5, oR, r);
        g = blend(0.5, oG, g);
        b = blend(0.5, oB, b);
      }
      ledBuffer[position + 1] = r;
      ledBuffer[position + 0] = g;
      ledBuffer[position + 2] = b;
    }
    function hsv(pixel, hue, sat, val, mode = COLOR_SET) {
      val = gamma8[uint8(val)];
      sat = 255 - gamma8[255 - uint8(sat)];
      let base;
      if (sat == 0) {
        rgb(pixel, val, val, val, mode);
      } else {
        base = Math.floor(((255 - sat) * val) >> 8);
        switch (Math.floor(hue / 60)) {
          case 0:
            return rgb(
              pixel,
              val,
              ((val - base) * hue) / 60 + base,
              base,
              mode
            );
          case 1:
            return rgb(
              pixel,
              ((val - base) * (60 - (hue % 60))) / 60 + base,
              val,
              base,
              mode
            );
          case 2:
            return rgb(
              pixel,
              base,
              val,
              ((val - base) * (hue % 60)) / 60 + base,
              mode
            );
          case 3:
            return rgb(
              pixel,
              base,
              ((val - base) * (60 - (hue % 60))) / 60 + base,
              val,
              mode
            );
          case 4:
            return rgb(
              pixel,
              ((val - base) * (hue % 60)) / 60 + base,
              base,
              val,
              mode
            );
          case 5:
            return rgb(
              pixel,
              val,
              base,
              ((val - base) * (60 - (hue % 60))) / 60 + base,
              mode
            );
        }
      }
    }
    function rope_fade(amount) {
      for (let k = 0; k < ROPE_LEDS * 3; k++) {
        ledBuffer[k] = ledBuffer[k] > amount ? ledBuffer[k] - amount : 0;
      }
    }
    function rope_rgb(r, g, b) {
      for (let k = 0; k < ROPE_LEDS; k++) {
        rgb(k, r, g, b);
      }
    }
    function rope_hsv(hue, sat, val) {
      for (let k = 0; k < ROPE_LEDS; k++) {
        hsv(k, hue, sat, val);
      }
    }
    function mult_rgb(r, g, b) {
      r_mult = r;
      g_mult = g;
      b_mult = b;
    }
    function switch_light(on) {
      if (on) {
        digitalWrite(RELAY_PIN, LOW);
      } else {
        digitalWrite(RELAY_PIN, HIGH);
      }
    }
    function set_mode(mode) {
      rope_clear();
      current_mode = mode;
      color_mode = HSV;
      last_auto = 0;
      fade_speed = 16;
      state = 0;
      state_loop = 0;
      collision_mode = COLLIDE_OFF;
      collide_same_direction = false;
      for (let k = 0; k < MAX_PARTICLES; k++) {
        particles[k].age = 0;
        particles[k].len = 0;
        particles[k].respawn = 0;
      }
    }

    function display_reset() {
      if (current_mode == FLASH) {
        set_mode(OFF);
      }
    }
    function setup() {
      log("Display started!");
      set_mode(OFF);
    }
    function point_render(k) {
      let hue = particles[k].hue;
      let highlight = Math.floor(particles[k].pos / POS_SCALE);
      let length = min(particles[k].len, particles[k].age);
      let bright = particles[k].bright;
      if (collision_mode == COLLIDE_BOOM) {
        if (particles[k].respawn > 0) {
          if (particles[k].age > bright) {
            return;
          }
          bright -= particles[k].age;
        } else {
          bright = min(particles[k].age, bright);
        }
      }
      if (!particles[k].wrap) {
        if (particles[k].speed >= 0) {
          length = min(length, highlight);
        } else {
          length = min(length, ROPE_LEDS - highlight);
        }
      }
      if (color_mode == HSV) {
        for (let tail = 0; tail < length; tail++) {
          hsv(
            (highlight - (particles[k].speed >= 0 ? tail : -tail) + ROPE_LEDS) %
              ROPE_LEDS,
            hue,
            255,
            (bright * (length - tail)) / length,
            COLOR_ADD
          );
        }
      } else if (color_mode == RGB) {
        for (let tail = 0; tail < length; tail++) {
          let tailBright = (bright * (length - tail)) / length;
          rgb(
            (highlight - (particles[k].speed >= 0 ? tail : -tail) + ROPE_LEDS) %
              ROPE_LEDS,
            min(r_mult, bright),
            min(g_mult, bright),
            min(b_mult, bright),
            COLOR_ADD
          );
        }
      } else {
        log("Unknown color_mode");
      }
    }
    function distance(k, j) {
      let d = abs(k - j);
      return min(d, ROPE_LEDS - d);
    }

    function loop() {
      if (last_auto > 0) {
        if (millis() - last_auto > 5000) {
          set_mode((current_mode + 1) % NUM_DISPLAY_MODES);
          last_auto = millis();
        }
      }
      render_mode();
      state = uint16(state + 1);
      if (state_loop && state >= state_loop) {
        state = 0;
        display_reset();
      }
    }
    function message(msg) {
      if (msg === "LIGHT") {
        switch_light(true);
      } else if (msg === "ON") {
        switch_light(true);
        set_mode(CHASE);
        last_auto = millis();
      } else if (msg === "CHASE") {
        set_mode(CHASE);
        for (let k = 0; k < 8; k++) {
          particles[k].pos = random(POS_SCALE * ROPE_LEDS);
          particles[k].hue = random(360);
          particles[k].len = 8;
          particles[k].speed = k == 0 ? -1 : k;
          particles[k].hue_v = 1;
          particles[k].bright = 255;
          particles[k].wrap = true;
        }
        collision_mode = COLLIDE_BOOM;
        fade_speed = 64;
      } else if (msg === "RANDCHASE") {
        set_mode(CHASE);
        let count = min(
          random(4, MAX_PARTICLES + 1),
          random(4, MAX_PARTICLES + 1),
          random(2, MAX_PARTICLES + 1)
        );
        let reverse = random(count);
        for (let k = 0; k < count; k++) {
          particles[k].pos = random(POS_SCALE * ROPE_LEDS);
          particles[k].hue = random(360);
          particles[k].len = random(4, 8);
          particles[k].speed =
            k <= reverse ? -random(1, count) : random(1, count);
          particles[k].hue_v = random(1);
          particles[k].bright = random(192, 256);
          particles[k].wrap = true;
        }
        collision_mode = COLLIDE_BOOM;
        collide_same_direction = random(1) ? true : false;
        fade_speed = 64;
      } else if (msg === "FLOWER") {
        set_mode(CHASE);
        fade_speed = 2;
        for (let k = 0; k < 2; k++) {
          particles[k].pos = 0;
          particles[k].hue = 0;
          particles[k].len = 50;
          particles[k].speed = k == 0 ? -5 : 5;
          particles[k].hue_v = 0;
          particles[k].bright = 64;
          particles[k].wrap = false;
        }
        fade_speed = 8;
        color_mode = RGB;
        mult_rgb(255, 0, 0);
      } else if (msg === "PULSE") {
        set_mode(PULSE);
        state_loop = 512;
      } else if (msg === "SPARKLE") {
        set_mode(SPARKLE);
        fade_speed = 1;
      } else if (msg === "NOISE") {
        set_mode(NOISE);
      } else if (msg === "FLASH") {
        set_mode(FLASH);
        state_loop = uint8(512 / FLASH_STEP);
        mult_rgb(50, 50, 50);
      } else if (msg === "RED") {
        mult_rgb(255, 0, 0);
      } else if (msg === "GREEN") {
        mult_rgb(0, 255, 0);
      } else if (msg === "BLUE") {
        mult_rgb(0, 0, 255);
      } else if (msg === "YELLOW") {
        mult_rgb(255, 255, 0);
      } else if (msg === "TURQUOISE") {
        mult_rgb(0, 255, 255);
      } else if (msg === "PINK") {
        mult_rgb(255, 0, 255);
      } else if (msg === "RAINBOW") {
        set_mode(RAINBOW);
        state_loop = 360;
      } else if (msg === "RANDOM") {
        let next = random(NUM_DISPLAY_MODES);
        for (; next == current_mode; ) {
          next = random(NUM_DISPLAY_MODES);
        }
        set_mode(next);
      } else if (msg === "NEXT") {
        set_mode((current_mode + 1) % NUM_DISPLAY_MODES);
      } else if (msg === "OFF") {
        switch_light(false);
        set_mode(OFF);
      } else if (msg === "AUTO") {
        if (current_mode >= NUM_DISPLAY_MODES) {
          set_mode(random(NUM_DISPLAY_MODES));
        }
        last_auto = millis() + 1;
      } else if (msg === "GLOW") {
        display_setup(GLOW);
      } else if (msg === "LEDS") {
        display_setup(LEDS);
      } else if (msg === "JOIN_HALVES") {
        display_setup(JOIN_HALVES);
      } else {
        if (message[0] == "#") {
        } else {
        }
      }
    }
    function render_mode() {
      if (current_mode === OFF) {
        rope_rgb(0, 0, 0);
      } else if (current_mode === GLOW) {
        for (let k = 0; k < ROPE_LEDS; k++) {
          if (k < 200 && k % 2 == 0) {
            rgb(k, 200, 120, 30);
          } else {
            rgb(k, 0, 0, 0);
          }
        }
      } else if (current_mode === PULSE) {
        let pulse = 0;
        if (state < 256) {
          pulse = state % 256;
        } else {
          pulse = 255 - ((state - 256) % 256);
        }
        rope_rgb(min(32 + pulse, 255), 0, 0);
      } else if (current_mode === SPARKLE) {
        if (state % 5 == 0) {
          hsv(random(ROPE_LEDS), random(360), 255, random(96, 256), COLOR_ADD);
        }
        if (state % 2 == 0) {
          rope_fade(1);
        }
        delay(10);
      } else if (current_mode === NOISE) {
        for (let i = 0; i < ROPE_LEDS; i++) {
          let value = gamma8_floor[random(256)];
          rgb(i, value, value, value);
        }
      } else if (current_mode === FLASH) {
        let partial = 0;
        let flashState = state * FLASH_STEP;
        let bright = min(255, flashState > 255 ? 512 - flashState : flashState);
        for (let i = 0; i < ROPE_LEDS; i++) {
          let value = gamma8_floor[bright];
          partial = gamma8_partial[bright];
          if (partial >= 128 && i % 2 == 0) {
            value += 1;
          } else if (partial >= 64 && i % 4 == 0) {
            value += 1;
          } else if (partial >= 32 && i % 8 == 0) {
            value += 1;
          } else if (partial >= 16 && i % 16 == 0) {
            value += 1;
          }
          rgb(i, min(r_mult, value), min(g_mult, value), min(b_mult, value));
        }
      } else if (current_mode === RAINBOW) {
        particles[0].pos = (particles[0].pos + 1) % ROPE_LEDS;
        let dark = particles[0].pos;
        for (let k = 0; k < ROPE_LEDS; k++) {
          let dist = distance(k, dark);
          hsv(
            k,
            (state + k) % 360,
            255,
            dist < 25 ? 255 - 10 * (25 - dist) : 255
          );
        }
        delay(50);
      } else if (current_mode === CHASE) {
        rope_fade(fade_speed);
        for (let k = 0; k < MAX_PARTICLES; k++) {
          if (particles[k].len == 0) {
            continue;
          }
          if (particles[k].respawn > 0) {
            particles[k].respawn--;
            if (particles[k].respawn == 0) {
              particles[k].age = 0;
              particles[k].pos = random(POS_MAX);
            }
          }
          point_render(k);
          if (particles[k].age < UINT_MAX) {
            particles[k].age++;
          }
          if (particles[k].respawn > 0) {
            continue;
          }
          particles[k].hue =
            (particles[k].hue + particles[k].hue_v + 360) % 360;
          let pos = particles[k].pos / POS_SCALE;
          if (state % 3 == 0 && pos >= 200 && pos <= 250) {
            continue;
          }
          let prevPos = particles[k].pos;
          let nextPos =
            (particles[k].pos + particles[k].speed + POS_MAX) % POS_MAX;
          particles[k].pos = nextPos;
          if (collision_mode != COLLIDE_BOOM) {
            continue;
          }
          for (let j = 0; j < MAX_PARTICLES; j++) {
            if (
              k == j ||
              particles[j].len == 0 ||
              particles[j].age < 256 ||
              particles[j].respawn != 0
            ) {
              continue;
            }
            let collided =
              ((prevPos < particles[j].pos && nextPos >= particles[j].pos) ||
                (prevPos > particles[j].pos && nextPos <= particles[j].pos)) &&
              abs(prevPos - nextPos < POS_MAX / 2) &&
              (collide_same_direction ||
                particles[k].speed * particles[j].speed < 0);
            if (collided) {
              log("Boom!");
              particles[k].respawn = 256 + random(256);
              particles[k].age = 0;
              particles[j].respawn = 256 + random(256);
              particles[j].age = 0;
            }
          }
        }
      } else if (current_mode === LEDS) {
        for (let k = 0; k < ROPE_LEDS; k++) {
          if (k % 25 == 0) {
            rgb(k, 255, 255, 255);
          } else if (k % 10 == 0) {
            rgb(k, 255, 0, 0);
          } else if (k % 5 == 0) {
            rgb(k, 0, 255, 0);
          } else if (k % 2 == 0) {
            rgb(k, 0, 0, 255);
          }
        }
      } else if (current_mode === JOIN_HALVES) {
        let half = ROPE_LEDS / 2;
        for (let k = 0; k < half; k++) {
          hsv(k, (state + k) % 360, 255, k < state % half ? 255 : 0);
          hsv(
            ROPE_LEDS - k - 1,
            (state + k) % 360,
            255,
            k < state % half ? 255 : 0
          );
        }
      }
    }

    return { setup, loop, message };
  };
})();
